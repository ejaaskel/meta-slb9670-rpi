From 795b4afa1170a78dae40311d37d7e706d176cf73 Mon Sep 17 00:00:00 2001
From: Pierre Fontaine <pierre.ftn@pfontaine.fr>
Date: Mon, 13 Apr 2020 17:42:13 +0200
Subject: [PATCH 18/18] Patching drivers in order to enable communication
 between the RaspberryPi4 and the tpm2 through SPI bus. Thoses patches are
 based on the work done by J.Holland and those who contributed on a more
 recent branch.

Signed-off-by: Pierre Fontaine <pierre.ftn@pfontaine.fr>
---
 drivers/spi/soft_spi.c     | 60 ++++++++++++++++++++++++++++----------
 drivers/tpm/tpm2_tis_spi.c | 18 ++++++++----
 2 files changed, 58 insertions(+), 20 deletions(-)

diff --git a/drivers/spi/soft_spi.c b/drivers/spi/soft_spi.c
index b06883f9d0..5932ce8c5c 100644
--- a/drivers/spi/soft_spi.c
+++ b/drivers/spi/soft_spi.c
@@ -58,10 +58,12 @@ static int soft_spi_sda(struct udevice *dev, int bit)
 static int soft_spi_cs_activate(struct udevice *dev)
 {
 	struct udevice *bus = dev_get_parent(dev);
+	struct soft_spi_priv *priv = dev_get_priv(bus);
 	struct soft_spi_platdata *plat = dev_get_platdata(bus);
+	int cidle = !!(priv->mode & SPI_CPOL);
 
 	dm_gpio_set_value(&plat->cs, 0);
-	dm_gpio_set_value(&plat->sclk, 0);
+	dm_gpio_set_value(&plat->sclk, cidle); /* to idle */
 	dm_gpio_set_value(&plat->cs, 1);
 
 	return 0;
@@ -79,11 +81,14 @@ static int soft_spi_cs_deactivate(struct udevice *dev)
 
 static int soft_spi_claim_bus(struct udevice *dev)
 {
+	struct udevice *bus = dev_get_parent(dev);
+	struct soft_spi_priv *priv = dev_get_priv(bus);
+	int cidle = !!(priv->mode & SPI_CPOL);
 	/*
 	 * Make sure the SPI clock is in idle state as defined for
 	 * this slave.
 	 */
-	return soft_spi_scl(dev, 0);
+	return soft_spi_scl(dev, cidle);
 }
 
 static int soft_spi_release_bus(struct udevice *dev)
@@ -114,15 +119,18 @@ static int soft_spi_xfer(struct udevice *dev, unsigned int bitlen,
 	uchar		tmpdout = 0;
 	const u8	*txd = dout;
 	u8		*rxd = din;
-	int		cpha = priv->mode & SPI_CPHA;
+	int		cpha = !!(priv->mode & SPI_CPHA);
+	int		cidle = !!(priv->mode & SPI_CPOL);
 	unsigned int	j;
 
 	debug("spi_xfer: slave %s:%s dout %08X din %08X bitlen %u\n",
 	      dev->parent->name, dev->name, *(uint *)txd, *(uint *)rxd,
 	      bitlen);
 
-	if (flags & SPI_XFER_BEGIN)
+	if (flags & SPI_XFER_BEGIN) {
 		soft_spi_cs_activate(dev);
+		udelay(plat->spi_delay_us);
+	}
 
 	for (j = 0; j < bitlen; j++) {
 		/*
@@ -140,22 +148,42 @@ static int soft_spi_xfer(struct udevice *dev, unsigned int bitlen,
 			tmpdin  = 0;
 		}
 
-		if (!cpha)
-			soft_spi_scl(dev, 0);
+		/*
+		 * CPOL 0: idle is low (0), active is high (1)
+		 * CPOL 1: idle is high (1), active is low (0)
+		 */
+
+		/*
+		 * drive bit
+		 *  CPHA 1: CLK from idle to active
+		 */
+		if (cpha)
+			soft_spi_scl(dev, !cidle);
 		if ((plat->flags & SPI_MASTER_NO_TX) == 0)
 			soft_spi_sda(dev, !!(tmpdout & 0x80));
 		udelay(plat->spi_delay_us);
-		if (cpha)
-			soft_spi_scl(dev, 0);
+
+		/*
+		 * sample bit
+		 *  CPHA 0: CLK from idle to active
+		 *  CPHA 1: CLK from active to idle
+		 */
+		if (!cpha)
+			soft_spi_scl(dev, !cidle);
 		else
-			soft_spi_scl(dev, 1);
+			soft_spi_scl(dev, cidle);
 		tmpdin	<<= 1;
 		if ((plat->flags & SPI_MASTER_NO_RX) == 0)
 			tmpdin	|= dm_gpio_get_value(&plat->miso);
 		tmpdout	<<= 1;
 		udelay(plat->spi_delay_us);
-		if (cpha)
-			soft_spi_scl(dev, 1);
+
+		/*
+		 * drive bit
+		 *  CPHA 0: CLK from active to idle
+		 */
+		if (!cpha)
+			soft_spi_scl(dev, cidle);
 	}
 	/*
 	 * If the number of bits isn't a multiple of 8, shift the last
@@ -168,15 +196,17 @@ static int soft_spi_xfer(struct udevice *dev, unsigned int bitlen,
 		*rxd++ = tmpdin;
 	}
 
-	if (flags & SPI_XFER_END)
+	if (flags & SPI_XFER_END) {
+		udelay(plat->spi_delay_us);
 		soft_spi_cs_deactivate(dev);
+	}
 
 	return 0;
 }
 
 static int soft_spi_set_speed(struct udevice *dev, unsigned int speed)
 {
-	/* Accept any speed */
+	/* Ignore any speed settings. Speed is implemented via "spi-delay-us" */
 	return 0;
 }
 
@@ -215,8 +245,8 @@ static int soft_spi_probe(struct udevice *dev)
 	int cs_flags, clk_flags;
 	int ret;
 
-	cs_flags = (slave->mode & SPI_CS_HIGH) ? 0 : GPIOD_ACTIVE_LOW;
-	clk_flags = (slave->mode & SPI_CPOL) ? GPIOD_ACTIVE_LOW : 0;
+	cs_flags = (slave && slave->mode & SPI_CS_HIGH) ? 0 : GPIOD_ACTIVE_LOW;
+	clk_flags = (slave && slave->mode & SPI_CPOL) ? GPIOD_ACTIVE_LOW : 0;
 
 	if (gpio_request_by_name(dev, "cs-gpios", 0, &plat->cs,
 				 GPIOD_IS_OUT | cs_flags) ||
diff --git a/drivers/tpm/tpm2_tis_spi.c b/drivers/tpm/tpm2_tis_spi.c
index 8878130bd7..713111f6c3 100644
--- a/drivers/tpm/tpm2_tis_spi.c
+++ b/drivers/tpm/tpm2_tis_spi.c
@@ -295,6 +295,14 @@ static int tpm_tis_spi_wait_for_stat(struct udevice *dev, u8 mask,
 	return -ETIMEDOUT;
 }
 
+static u8 tpm_tis_spi_valid_status(struct udevice *dev, u8 *status)
+{
+	struct tpm_chip *chip = dev_get_priv(dev);
+
+	return tpm_tis_spi_wait_for_stat(dev, TPM_STS_VALID,
+		chip->timeout_c, status);
+}
+
 static int tpm_tis_spi_get_burstcount(struct udevice *dev)
 {
 	struct tpm_chip *chip = dev_get_priv(dev);
@@ -455,7 +463,7 @@ static int tpm_tis_spi_send(struct udevice *dev, const u8 *buf, size_t len)
 		i += size;
 	}
 
-	ret = tpm_tis_spi_status(dev, &status);
+	ret = tpm_tis_spi_valid_status(dev, &status);
 	if (ret)
 		goto out_err;
 
@@ -469,7 +477,7 @@ static int tpm_tis_spi_send(struct udevice *dev, const u8 *buf, size_t len)
 	if (ret)
 		goto out_err;
 
-	ret = tpm_tis_spi_status(dev, &status);
+	ret = tpm_tis_spi_valid_status(dev, &status);
 	if (ret)
 		goto out_err;
 
@@ -579,7 +587,7 @@ static int tpm_tis_spi_probe(struct udevice *dev)
 	/* Use the TPM v2 stack */
 	priv->version = TPM_V2;
 
-	if (IS_ENABLED(CONFIG_DM_GPIO)) {
+	if (CONFIG_IS_ENABLED(DM_GPIO)) {
 		struct gpio_desc reset_gpio;
 
 		ret = gpio_request_by_name(dev, "gpio-reset", 0,
@@ -588,9 +596,9 @@ static int tpm_tis_spi_probe(struct udevice *dev)
 			log(LOGC_NONE, LOGL_NOTICE, "%s: missing reset GPIO\n",
 			    __func__);
 		} else {
-			dm_gpio_set_value(&reset_gpio, 0);
-			mdelay(1);
 			dm_gpio_set_value(&reset_gpio, 1);
+			mdelay(1);
+			dm_gpio_set_value(&reset_gpio, 0);
 		}
 	}
 
-- 
2.21.1
